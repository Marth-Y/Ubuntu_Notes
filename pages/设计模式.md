- ==类与类之间的五种关系== #CPP #设计模式
  collapsed:: true
	- ## 1.垂直方向一种
		- ### 1.继承
			- 在语义上表达的是A is B或者IS-A的关系=》派生类必须要是一个基类
			- 基类部分会成为派生类一部分，紧耦合的。
			- 在设计时，不要轻易使用继承
			- 在UML类图中，使用空心的三角箭头表示，并且箭头指向的是基类
	- ## 2.水平方向四种
		- 依赖<关联<聚合<组合
		- 组合和继承耦合性强弱对比
			- 对于继承：基类就是派生类的一部分，派生类知道基类的内部
			- 对于组合，类并不知道其一个类对象的内部如何。
			- 所以继承的耦合性更强
		- ### 2.依赖
			- 在语义上，是A use B的关系。
			- 在代码上，**用成员函数来表现。**
				- 1.通过**成员函数参数**来体现
				- 2.在A**成员函数内部创建B的对象**。
				- 3.B作为A的**成员函数的返回值**
					- A和B本来没关系，互相都不是对方的数据成员，但是可以通过函数、对象、函数返回值建立起了联系。如：宠物和主人，互相本来没什么关系，但是主人通过喂食这一行为和宠物产生了联系。
			- 这种关系是临时的，并非固定的，只要不调用该函数，A和B彼此无关。
			- 在类图上，依赖用虚线箭头表示
				- 关系最弱，虚线，若有若无
		- ### 3.关联
			- 在语义上，A has B，has表示拥有
			- 在代码上，B作为A的数据成员出现，**可以是指针或者引用成员**
			- 前提：A和B彼此并不负责对方的生命周期。
				- 即：两个类各自有自己独立的生命周期
			- 有两种表现形式
				- 1.单向的关联关系，在类图上，用直线箭头表示
					- 条件变量与互斥锁彼此并不负责对方的生命周期，条件变量知道互斥锁的存在，但互斥锁并不知道条件变量的存在，称其为单向的关联关系。条件变量拥有互斥锁。
				- 2.双向的关联关系，在类图上，用直线表示
					- 顾客与订单信息彼此都知道对方的存在。顾客拥有订单信息
		- ### 4.聚合
			- 在语义上，是A has B的关系，是一种比较强的关联关系。
				- 是关联的升级
			- 在代码上，**用指针或者引用**。
			- 具有整体和局部的概念，整体拥有局部的，**但整体并不负责局部的生命周期**
				- 如：电脑拥有各个零件，但是电脑并不负责各个零件的生命周期。而且电脑被拆了，但是零件还能用，电脑已经没了。
			- 在类图上，用空心的菱形箭头表示，箭头指向的是整体。
		- ### 5.组合
			- 在语义上，是A has B的关系，是一种更强的关联关系。
			- 在代码上，**用类对象成员表示**
				- 就是成为它的一个类对象数据成员。
			- 具有整体和局部的概念，整体拥有局部的，**且整体负责局部的生命周期**
				- 如：公司和各部门，及各部门工作人员的关系。一旦公司倒闭了，这些部门和工作人员就都没了
- 策略模式 #设计模式
  collapsed:: true
	- 当一个对象可能调用不同的算法实现一个功能的时候，可以考虑策略模式。
	- 原理
		- 利用==多态==以及虚函数基类实现。
	- 大白话来说就是：策略模式提供了相同的接口，但是利用多态在接口内部可以采用不同的算法去做，这样可以在调用的时候做选择，使用哪一种方法。这样提供了高可扩展性，实现算法可以随时更换以及加入新的算法。
		- 缺点：想要采用的算法越多，需要实现的类就越多。而且需要客户端对每一个类如何调用有清晰得认知。
	- 例：最近工作中我要实现对地面元素的跟踪，而且可能需要流出occupancy的方式跟踪的扩展。因此我采用了策略模式，便于之后可能更换occupancy的方式跟踪。
	- 使用上下文context切换使用的算法。也可以在需要使用的对象初始化函数直接传入TrackBase类型的指针，如此完成多态
	- 代码示例：
		- ```cpp
		  #include <iostream>
		  #include <memory>
		  #include <string>
		  using namespace std;
		  
		  class TrackBase
		  {
		    public:
		      virtual void Track() = 0;
		  };
		  
		  class ArrowWorldTrack : public TrackBase
		  {
		    public:
		      void Track() { std::cout << "world" << std::endl; }
		  };
		  
		  class ArrowOccupancyTrack : public TrackBase
		  {
		    public:
		      void Track() { std::cout << "occupancy" << std::endl; }
		  };
		  
		  class Context
		  {
		    public:
		      void Set(std::unique_ptr<TrackBase> tracker)
		      {
		          tracker_ = std::move(tracker);
		      }
		      void Track() { tracker_->Track(); }
		  
		    private:
		      std::unique_ptr<TrackBase> tracker_;
		  };
		  
		  int main() 
		  {
		      std::unique_ptr<TrackBase> tracker(new ArrowOccupancyTrack);
		      Context context;
		      context.Set(std::move(tracker));
		      context.Track();
		  }
		  ```
	-
	-
	-
-